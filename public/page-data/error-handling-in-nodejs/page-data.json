{"componentChunkName":"component---src-templates-blog-post-js","path":"/error-handling-in-nodejs/","result":{"data":{"site":{"siteMetadata":{"title":"Welcome To My Blog"}},"markdownRemark":{"id":"c3e9f129-30e0-5548-8534-64584121982b","excerpt":"When I was studying the Jira Clone Repository, I came across a few interesting design decisions and implementations. This post is a review about the error…","html":"<p>When I was studying the Jira Clone Repository, I came across a few interesting design decisions and implementations. This post is a review about the error design pattern implemented in Jira Clone Repository. I took a vow to write clean code or atleast try.</p>\n<p>This post provides a detailed outline of error handling</p>\n<h2>Error status code and message handler</h2>\n<h2>Problem:</h2>\n<p>I have encountered a few common problems that this design pattern helped me solve, especially when it had to do with sending correct status code and valid error messages.</p>\n<p>Let me provide an instance. I was working on this project that used NodeJs that should have valid, meaningful error codes and messages. There was this one particular endpoint that had a missing status code as part of the response being sent.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return res.send({\n  message: ‘This is an error!’\n});</code></pre></div>\n<p>In the above snippet unless you explicitly set status, it defaults to 200. Well that cannot be the case when it is an error.</p>\n<p>Deployed to production and after a few hours, realized that the status code was responding with 200 even when there was an error. These status codes were really important in this project because I relied on those status codes to perform further DB operations. After some investigation, I found that it had missing status code being set like the following</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">return res.send({\n  message: ‘This is an error!’\n});</code></pre></div>\n<h2>Solution:</h2>\n<h3>CustomError class</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/* eslint-disable max-classes-per-file */\n\ntype ErrorData = { [key: string]: any };\n\nexport class CustomError extends Error {\n  constructor(\n    public message: string,\n    public code: string | number = \"INTERNAL_ERROR\",\n    public status: number = 500,\n    public data: ErrorData = {}\n  ) {\n    super();\n  }\n}\n\nexport class RouteNotFoundError extends CustomError {\n  constructor(originalUrl: string) {\n    super(`Route '${originalUrl}' does not exist.`, \"ROUTE_NOT_FOUND\", 404);\n  }\n}\n\nexport class EntityNotFoundError extends CustomError {\n  constructor(entityName: string) {\n    super(`${entityName} not found.`, \"ENTITY_NOT_FOUND\", 404);\n  }\n}\n\nexport class BadUserInputError extends CustomError {\n  constructor(errorData: ErrorData) {\n    super(\"There were validation errors.\", \"BAD_USER_INPUT\", 400, errorData);\n  }\n}\n\nexport class InvalidTokenError extends CustomError {\n  constructor(message = \"Authentication token is invalid.\") {\n    super(message, \"INVALID_TOKEN\", 401);\n  }\n}</code></pre></div>\n<p>Here the CustomError class is extended by specific errors such as RouteNotFoundError, EntityNotFoundError, BadUserInputError, InvalidTokenError.</p>\n<p>If it helps, you can create a file for each class, for example, you can put BadUserInputError into src/errors/customErrors/badUserInputError to follow the <a href=\"https://en.wikipedia.org/wiki/Single-responsibility_principle\">Single Responsibility Principle</a>. Though this decision/choice is completely up to the dev.</p>\n<h3>CatchErrors wrapper</h3>\n<p>Create a catchErrors wrapper in src/errors/asyncCatch.ts with the following code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { RequestHandler } from \"express\";\n\nexport const catchErrors = (requestHandler: RequestHandler): RequestHandler => {\n  return async (req, res, next): Promise&lt;any> => {\n    try {\n      return await requestHandler(req, res, next);\n    } catch (error) {\n      next(error);\n    }\n  };\n};</code></pre></div>\n<p>The following is a usage example in a controller function:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const getProjectWithUsersAndIssues = catchErrors(async (req, res) => {\n  const project = await findEntityOrThrow(Project, req.currentUser.projectId, {\n    relations: ['users', 'issues'],\n  });\n  res.respond({\n    project: {\n      ...project,\n      issues: project.issues.map(issuePartial),\n    },\n  });\n});</code></pre></div>\n<p>Notice the function named *findEntityorThrow. *It is self explanatory, it either fetches or throws errors. And when the error is thrown, it is caught and passed to chain of middleware through next(error)</p>\n<p>And this error is caught at src/index.ts as shown below</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const initializeExpress = (): void => {\n  const app = express();\n\n  app.use(cors());\n  app.use(express.json());\n  app.use(express.urlencoded());\n\n  app.use(addRespondToResponse);\n\n  attachPublicRoutes(app);\n\n  app.use('/', authenticateUser);\n\n  attachPrivateRoutes(app);\n\n  app.use((req, _res, next) => next(new RouteNotFoundError(req.originalUrl)));\n  app.use(handleError);\n\n  app.listen(process.env.PORT || 3000);\n};\n\nconst initializeApp = async (): Promise&lt;void> => {\n  await establishDatabaseConnection();\n  initializeExpress();\n};\n\n\ninitializeApp();</code></pre></div>\n<p>To be precise, the next in the chain of middleware is handled by <em>app.use(handleError)</em></p>\n<h3>handleError</h3>\n<p>The following snippet shows the handleError function</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { ErrorRequestHandler } from \"express\";\nimport { pick } from \"lodash\";\n\nimport { CustomError } from \"errors\";\n\nexport const handleError: ErrorRequestHandler = (error, _req, res, _next) => {\n  console.error(error);\n\n  const isErrorSafeForClient = error instanceof CustomError;\n\n  const clientError = isErrorSafeForClient\n    ? pick(error, [\"message\", \"code\", \"status\", \"data\"])\n    : {\n        message: \"Something went wrong, please contact our support.\",\n        code: \"INTERNAL_ERROR\",\n        status: 500,\n        data: {},\n      };\n\n  res.status(clientError.status).send({ error: clientError });\n};</code></pre></div>\n<p>isErrorSafeForClient checks if an error is an instance of CustomError. If it is an instance of CustomError, we use a function named <a href=\"https://lodash.com/docs/#pick\">*pick</a> *from lodash.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pick(error, [‘message’, ‘code’, ‘status’, ‘data’])</code></pre></div>\n<p>The above line always ensures that message, code, status, data are available and each response is consistent with this information that can be used by the client safely and reliably.</p>\n<h3>Example one:</h3>\n<p>Let’s pick BadUserInputError. We can throw the following anywhere in our codebase where it is relevant</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">throw new BadUserInputError({ fields: errorFields });</code></pre></div>\n<p>BadUserInputError class:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export class BadUserInputError extends CustomError {\n  constructor(errorData: ErrorData) {\n    super(\"There were validation errors.\", \"BAD_USER_INPUT\", 400, errorData);\n  }\n}</code></pre></div>\n<p>CustomError class:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export class CustomError extends Error {\n  constructor(\n  public message: string,\n  public code: string | number = 'INTERNAL_ERROR',\n  public status: number = 500,\n  public data: ErrorData = {},\n  ) {\n  super();\n}</code></pre></div>\n<p>Here clientError object is as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n “message”: “There were validation errors.”,\n “code”: “BAD_USER_INPUT”,\n “status”: 400,\n “data”:  {“fields”: &lt;errors>}\n}</code></pre></div>\n<h3>Example two:</h3>\n<p>Let’s pick InvalidTokenError. We can throw this error when we encounter invalid token error.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export const authenticateUser = catchErrors(async (req, _res, next) => {\n  const token = getAuthTokenFromRequest(req);\n  if (!token) {\n    throw new InvalidTokenError(\"Authentication token not found.\");\n  }\n  const userId = verifyToken(token).sub;\n  if (!userId) {\n    throw new InvalidTokenError(\"Authentication token is invalid.\");\n  }\n  const user = await User.findOne(userId);\n  if (!user) {\n    throw new InvalidTokenError(\n      \"Authentication token is invalid: User not found.\"\n    );\n  }\n  req.currentUser = user;\n  next();\n});</code></pre></div>\n<p>InvalidTokenError class:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export class InvalidTokenError extends CustomError {\n  constructor(message = \"Authentication token is invalid.\") {\n    super(message, \"INVALID_TOKEN\", 401);\n  }\n}</code></pre></div>\n<p>Here clientError object is as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  “message”: “Authentication token is invalid.”,\n  “code”: “INVALID_TOKEN”,\n  “status”: 400,\n  “data”: { }\n}</code></pre></div>\n<h3><strong>Conclusion:</strong></h3>\n<p>I have personally experienced some production issues because of inconsistency in the way errors were handled in a NodeJs based backend project. There could be other ways to handle errors better than this way, I liked this one. Hope you enjoyed reading this post.</p>","frontmatter":{"title":"A clean, better way to handle errors in NodeJs","date":"June 07, 2023","description":null}},"previous":null,"next":null},"pageContext":{"id":"c3e9f129-30e0-5548-8534-64584121982b","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}